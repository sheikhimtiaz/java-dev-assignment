/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package socket.server;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import socket.server.io.RequestObject;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class AppTest {
    InetAddress host;
    private static final int PORT = 9876;

    @BeforeEach
    void initialize() throws IOException {
        Runnable runnable = () -> {
            try {
                new App().startServerAndAcceptRequest();
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        };
        Thread serverThread = new Thread(runnable);
        serverThread.start();
        host = InetAddress.getLocalHost();
    }

    @Test
    void sendRequest() throws IOException, ClassNotFoundException, InterruptedException {
//        String[] methodParams = {"10", "1000000","200","50000"};
        String[] methodParams = {"10", "1000","200","50000"};
        for (int i = 0; i < 4; i++) {
            Socket socket = new Socket(host.getHostName(), PORT);
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
            RequestObject requestObject = new RequestObject();
            requestObject.managerName= "PrimeCalculationManager";
            requestObject.method="findPrimes";
            requestObject.args = new HashMap<>();
            requestObject.args.put("n", methodParams[i]);
            objectOutputStream.writeObject(requestObject);
            String message = (String) objectInputStream.readObject();
            System.out.println("Message from server: " + message);
            RequestObject requestObject2 = new RequestObject();
            requestObject2.method="EXIT";
            objectOutputStream.writeObject(requestObject2);
            objectOutputStream.close();
            objectInputStream.close();
            socket.close();
            Thread.sleep(100);
        }
    }


    @Test
    void sendMultipleAsyncRequestFromSingleClient() throws IOException, ClassNotFoundException, InterruptedException {
        // using one socket for every request here
        Socket socket = new Socket(host.getHostName(), PORT);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
        ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());

        String[] methodParams = {"10", "100000", "200", "50000"};
        for(int i=0; i<4; i++){
            RequestObject requestObject = new RequestObject();
            requestObject.managerName= "PrimeCalculationManager";
            requestObject.method="findPrimes";
            requestObject.args = new HashMap<>();
            requestObject.args.put("n", methodParams[i]);
            objectOutputStream.writeObject(requestObject);
        }

        for(int i=0; i<4; i++){
            String result = (String) objectInputStream.readObject();
            System.out.println("Message from server: " + result);
        }

        RequestObject requestObject3 = new RequestObject();
        requestObject3.method="EXIT";
        objectOutputStream.writeObject(requestObject3);

        objectOutputStream.close();
        objectInputStream.close();
        socket.close();
        Thread.sleep(100);
    }


    @Test
    void sendMultipleAsyncClientRequest() {
        // opening multiple socket here.
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        Runnable runnable = () -> {
            try {
                Socket socket = new Socket(host.getHostName(), PORT);
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
                RequestObject requestObject = new RequestObject();
                requestObject.managerName= "PrimeCalculationManager";
                requestObject.method="findPrimes";
                requestObject.args = new HashMap<>();
                requestObject.args.put("n", "100");
                objectOutputStream.writeObject(requestObject);
                ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
                String message = (String) objectInputStream.readObject();
                System.out.println("Message from server: " + message);
                RequestObject requestObject2 = new RequestObject();
                requestObject2.method="EXIT";
                objectOutputStream.writeObject(requestObject2);
                objectOutputStream.close();
                objectInputStream.close();
                socket.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        };

        List<Runnable> runnables = new ArrayList<>();
        for (int i=0; i<4; i++) {
            runnables.add(runnable);
        }

        CompletableFuture<?>[] futures = runnables.stream()
                .map(task -> CompletableFuture.runAsync(task, executorService))
                .toArray(CompletableFuture[]::new);

        CompletableFuture.allOf(futures).join();

        executorService.shutdown();
    }


    @AfterEach
    void cleanup() throws IOException, InterruptedException {
        Socket socket = new Socket(host.getHostName(), PORT);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
        RequestObject requestObject = new RequestObject();
        requestObject.managerName= "PrimeCalculationManager";
        requestObject.method="EXIT";
        objectOutputStream.writeObject(requestObject);
        Thread.sleep(100);
        objectOutputStream.close();
        socket.close();
    }
}
